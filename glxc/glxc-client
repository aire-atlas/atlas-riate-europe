#!/bin/bash
#
# glxc-client - both an "ext" git-remote and a helper to register it
#
# HISTORY
#   20140818 first version by JF Gigand <jf@geonef.fr>

nef_command_name=glxc-client
# . $(dirname $0)/../share/nef-common/shell-command || exit 2
glxc_executive_treeish=

######################################################################
# COMMANDS

# command: init <name>
#
# Copy the glxc-client to the .git if needed and register a GIT ext remote to it
##
glxc_command_init() {
    local _argv=()

    while [ -n "$1" ]; do
        case "$1" in
            -h) glxc_command_help init; return ;;
            -*) glxc_eval_common_option "$1"; shift ;;
            *) _argv=("${_argv[@]}" "$1"); shift ;;
        esac
    done

    [ "${#_argv[@]}" -lt 1 ] && nef_fatal_usage_command init "missing argument(s)"
    [ "${#_argv[@]}" -gt 1 ] && nef_fatal_usage_command init "too many arguments"

    local _name="${_argv[0]}"

    glxc_ensure_script_in_git_dir

    if git remote | grep -q "$_name"; then
        echo "Remote '$_name' exists already:"
        git remote -v | grep "^$_name"
    else
        echo "Remote '$_name' does not exists. Creating..."
        args=(git remote add $_name "ext::$glxc_git_dir/$nef_command_name remote $_name %S")
        echo ">" "${args[@]}"
        "${args[@]}"
    fi

    local _branch_name=$(git symbolic-ref --short HEAD 2>/dev/null)
    if [ -n "$_branch_name" ]; then
        _branch_name="$_branch_name # or another branch"
    else
        _branch_name="<branch>"
    fi
    echo
    echo "You may now run:"
    echo -e "\tgit push $_name $_branch_name"
    echo -e "\tgit pull $_name $_branch_name"
}

# command: remote <name> <remote-command>
#
# Handler for the "ext::" git remote
##
glxc_command_remote() {
    local _argv=()

    while [ -n "$1" ]; do
        case "$1" in
            -h) glxc_command_help init; return ;;
            -*) glxc_eval_common_option "$1"; shift ;;
            *) _argv=("${_argv[@]}" "$1"); shift ;;
        esac
    done

    [ "${#_argv[@]}" -lt 2 ] && nef_fatal_usage_command remote "missing argument(s)"
    [ "${#_argv[@]}" -gt 2 ] && nef_fatal_usage_command remote "too many arguments"

    local _name="${_argv[0]}"
    local _command="${_argv[1]}"
    echo argv "${_argv[@]}" >&2

    state=$(lxc-info -sHn $_name)

    if [ -z "$state" ]; then
        # [ -d "$engine_dir" ] || nef_fatal "container cannot be created as engine dir is not available: $engine_dir"
        nef_log "LXC container '$_name' does not exist. Creating..."
        lxc-create -n $_name -t download -- -d debian -r wheezy -a amd64 >&2 \
            || nef_fatal "lxc-create failed"
    fi

    state=$(lxc-info -sHn $_name)

    if [ "$state" = "STOPPED" ]; then
        nef_log "Container '$_name' is $state. Starting it..."
        lxc-start -n $_name -d \
            || nef_fatal "lxc-start failed"
        sleep 1
    fi

    lxc-attach --clear-env -n $_name -- test -d /sysconf || {
        nef_log "sysconf is not defined"
        # $glxc_executive_treeish
    }
    exit
    # lxc-setup is always (re-)run
    [ -f $(dirname $0)/glxc-server-setup ] || nef_fatal "missing: $(dirname $0)/glxc-server-setup"
    cat $(dirname $0)/glxc-server-setup | lxc-attach --clear-env -n $_name -- sh >&2


    nef_log "Forwarding command '$remote_command' to glxc in container '$_name'..."
    lxc-attach --clear-env -n $_name -- glxc git-remote-command $remote_command

}

# command: help [command]
#
# Print information about command usage.
#
# With no argument, a list of commands is printed.
##
glxc_command_help() {
    local _argv=()
    local _command=
    local _usage=0

    while [ -n "$1" ]; do
        case "$1" in
            --usage) _usage=1; shift ;;
            -h) glxc_command_help help; return ;;
            -*) glxc_eval_common_option "$1"; shift ;;
            *) _command="$1"; break ;;
        esac
    done

    nef_show_help $_command
}

######################################################################
# FUNCTIONALITY

glxc_ensure_script_in_git_dir() {
    cp $0 $glxc_git_dir/$nef_command_name \
        || nef_fatal "could not copy $0 to $glxc_git_dir/$nef_command_name"
    commit=$(git rev-parse HEAD)
    sed -i -r "s/^(glxc_executive_treeish)=(.*)/\1=$commit/" $glxc_git_dir/$nef_command_name
    # cp $(dirname $0)/glxc-server-setup $glxc_git_dir/
}

######################################################################
# COMMAND LINE & RUN

glxc_eval_common_option() {
    case "$1" in
        -v | --verbose) nef_opt_show_verbose=yes; shift ;;
        -vv | --debug-verbose) nef_opt_show_verbose=yes; nef_opt_show_debug=yes; shift ;;
        -h | --help) nef_show_usage; exit 0 ;;
        -*) nef_fatal_usage "bad option: $1" ;;
    esac
}

nef_fatal_usage_command() {
    local _command="$1"; shift

    nef_log "$_command usage error: $*"
    echo >&2
    glxc_command_help --usage "$_command" >&2
    exit 1
}

glxc_parse_cmdline() {
    nef_command_merge_env
    nef_command_init_options

    glxc_command_argv=()

    while [ -n "$1" ]; do

        case "$1" in
            -*) glxc_eval_common_option "$1"; shift ;;
            *) glxc_command_argv=("$@"); break ;;
        esac

    done

    [ -z "${glxc_command_argv[0]}" ] && glxc_command_argv=(help)
    glxc_git_dir=$(git rev-parse --git-dir)
    echo "$glxc_git_dir" | grep -q / || {
        glxc_git_dir=$PWD/$glxc_git_dir
    }
    [ -z "$glxc_git_dir" ] && nef_fatal "not in GIT directory or working tree"


    # Run command
    glxc_command_function_name="glxc_command_${glxc_command_argv[0]}"
    unset glxc_command_argv[0]
    $glxc_command_function_name "${glxc_command_argv[@]}" \
        || nef_fatal "command ${glxc_command_argv[0]} returned status $?"
    nef_log -v "Command returned successfully."
}

######################################################################
# FROM sysconf.base library

nef_log() {
    [ "x$NEF_LOG_FILE" = x ] && NEF_LOG_FILE="$LOG_FILE" # Legacy compat

    declare _opt_verbose=no
    declare _opt_debug=no
    declare _opt_prepend=""

    while [ "$1" != "" ]; do

        case "$1" in
            -p | --prepend) _opt_prepend="$2"; echo "prenddd..$2"; shift; shift ;;
            -v | --verbose) _opt_verbose=yes; shift ;;
            -d | --debug) _opt_debug=yes; shift ;;
            -*) nef_log "nef_log(): bad option: $1"; shift ;;
            *) break ;;
        esac

    done

    [ $_opt_verbose = yes -a x$nef_opt_show_verbose = xno ] && return 0
    [ $_opt_debug = yes -a x$nef_opt_show_debug = xno ] && return 0

    local txt="$*"
    local line="$*"
    local prefix=$(basename $0)

    if [ "x$NEF_LOG_DATE" = xyes ]; then
        date="`date +'%Y-%m-%d %H:%M:%S:%N' | sed -E 's/.{6}$//'`"
        prefix="$prefix $date"
    fi

    line="$prefix: ${_opt_prepend}${line}"

    if [ "$NEF_LOG_FILE" = "" ]; then
        echo "$line" >&2
    else
        echo "$line" | tee -a $LOG_FILE >&2
    fi
}

nef_fatal() {
    nef_log "FATAL ERROR: $*"
    exit 1;
}

nef_command_merge_env() {
    local _path=/etc/default/$nef_command_name

    if [ -f $_path ]; then
        nef_log -v "loading defaults from $_path"
        . $_path
    fi
}

nef_command_init_options()
{
    nef_command_path=$0
    nef_command_callname=$(basename $nef_command_path)
    [ "x$nef_command_name" = x ] && nef_command_name=$nef_command_callname

    nef_opt_show_verbose=no
    nef_opt_show_debug=no
}

# Usage: nef_show_help [command]
nef_show_help() {
    local _command="$1"
    local _keep_showing=0
    local _prefix1="usage: $nef_command_callname"
    local _prefix2=$(echo "$_prefix1" | sed "s/./ /g")

    if test -z "$_command"; then
        cmd_description=$(cat $(which "$0") | head -n 3 | tail -n 1 | sed -r 's/[^-]*- ?//')
        cat <<-EOF
	$nef_command_callname - $cmd_description

	$_prefix1 [--verbose] [--debug-verbose] [--help]
	$_prefix2 <command> [<args>]

	EOF
    fi
    grep -E ^# "$(which "$0")" | (
        while read; do
            local _command_name=
            local _line=$(echo "$REPLY" | sed -r 's/^# ?//')

            if test "$_keep_showing" -ne 0; then
                if echo "$REPLY" | grep -qE "^##"; then
                    _keep_showing=0
                    exit
                else
                    echo "$_line"
                    continue
                fi
            fi
            if echo "$_line" | grep -qE "^command:"; then
                full=$(echo "$_line" | sed 's/^command: //')
                _command_name=$(echo "$full" | sed 's/ .*//')
                _command_args=$(echo "$full" | sed -r 's/^[^ ]+ //')

                if test -n "$_command"; then
                    if test "$_command" = "$_command_name"; then
                        echo "usage: $nef_command_callname $_command $_command_args"
                        [ $_usage -eq 0 ] && _keep_showing=1
                    fi
                else
                    echo -e "    $_command_name\t$_command_args"
                fi
            fi
            if echo "$REPLY" | grep -qE "^### "; then
                if test -z "$_command"; then
                    full=$(echo "$REPLY" | sed 's/^### //')
                    echo
                    echo "  $full"
                    echo
                fi
            fi

        done
    )
    echo
}


######################################################################

glxc_parse_cmdline "$@"
